#!/usr/bin/env python3
"""
AGiXT Installer - Docker Module (CORRECTED)
===========================================

Handles Docker configuration and service management.
This module creates .env files, configures docker-compose.yml,
and starts all AGiXT services.

CORRECTED: Fixed to match the working installer exactly
- Removed wrong command (python3 DB.py)
- Fixed volume mappings to use absolute paths
- Mount .env as volume instead of env_file
- Proper directory structure
"""

import os
import subprocess
import time
from installer_utils import log, run_command

def create_configuration(install_path, config):
    """Create .env file and configure docker-compose.yml with all config values"""
    
    try:
        log("üê≥ Creating Docker configuration...")
        
        # Ensure we have the required dynamic values
        if 'INSTALL_DATE' not in config:
            from datetime import datetime
            config['INSTALL_DATE'] = datetime.now().isoformat()
            log("‚úÖ Added missing INSTALL_DATE: " + config['INSTALL_DATE'])
        
        if 'AGIXT_API_KEY' not in config:
            from installer_utils import generate_secure_api_key
            config['AGIXT_API_KEY'] = generate_secure_api_key()
            log("‚úÖ Added missing AGIXT_API_KEY: " + config['AGIXT_API_KEY'][:8] + "...")
        
        # Organize configuration values by category
        categories = {
            "VERSION & BASIC": [
                "AGIXT_VERSION", "INSTALL_DATE", "AGIXT_API_KEY", "UVICORN_WORKERS", 
                "WORKING_DIRECTORY", "TZ"
            ],
            "PROXY URLS": [
                "AGIXT_SERVER", "AGIXT_URI", "APP_URI", "AUTH_WEB"
            ],
            "INTERFACE": [
                "APP_NAME", "APP_DESCRIPTION", "AGIXT_AGENT", "AGIXT_SHOW_SELECTION",
                "AGIXT_SHOW_AGENT_BAR", "AGIXT_SHOW_APP_BAR", "AGIXT_CONVERSATION_MODE",
                "INTERACTIVE_MODE", "THEME_NAME", "AGIXT_FOOTER_MESSAGE"
            ],
            "AUTHENTICATION": [
                "AUTH_PROVIDER", "CREATE_AGENT_ON_REGISTER", "CREATE_AGIXT_AGENT",
                "ALLOW_EMAIL_SIGN_IN"
            ],
            "FEATURES": [
                "AGIXT_FILE_UPLOAD_ENABLED", "AGIXT_VOICE_INPUT_ENABLED", "AGIXT_RLHF",
                "AGIXT_ALLOW_MESSAGE_EDITING", "AGIXT_ALLOW_MESSAGE_DELETION",
                "AGIXT_SHOW_OVERRIDE_SWITCHES"
            ],
            "SYSTEM": [
                "DATABASE_TYPE", "DATABASE_NAME", "LOG_LEVEL", "LOG_FORMAT",
                "ALLOWED_DOMAINS", "AGIXT_BRANCH", "AGIXT_REQUIRE_API_KEY"
            ],
            "GRAPHQL": [
                "GRAPHIQL", "ENABLE_GRAPHQL"
            ],
            "HUGGINGFACE INTEGRATION": [
                "HUGGINGFACE_TOKEN"
            ],
            "EZLOCALAI INTEGRATION": [
                "EZLOCALAI_API_URL", "EZLOCALAI_API_KEY", "EZLOCALAI_TEMPERATURE",
                "EZLOCALAI_TOP_P", "EZLOCALAI_VOICE"
            ],
            "EZLOCALAI SERVER": [
                "DEFAULT_MODEL", "EZLOCALAI_MODEL", "LLM_MAX_TOKENS", "EZLOCALAI_MAX_TOKENS",
                "THREADS", "GPU_LAYERS", "WHISPER_MODEL", "IMG_ENABLED", "AUTO_UPDATE"
            ],
            "MODEL ARCHITECTURE": [
                "MODEL_ARCHITECTURE_TYPE", "MODEL_HIDDEN_SIZE", "MODEL_NUM_LAYERS",
                "MODEL_NUM_HEADS", "MODEL_NUM_KV_HEADS", "MODEL_VOCAB_SIZE",
                "MODEL_INTERMEDIATE_SIZE", "FINAL_MODEL_NAME", "FINAL_MODEL_FILE"
            ],
            "EXTERNAL SERVICES": [
                "TEXTGEN_URI", "N8N_URI"
            ]
        }
        
        # Create .env file
        env_path = os.path.join(install_path, ".env")
        log("üìÑ Creating .env file: " + env_path)
        
        with open(env_path, 'w') as f:
            f.write("# =============================================================================\n")
            f.write("# AGiXT Environment Configuration - Generated by Modular Installer\n")
            f.write("# =============================================================================\n")
            f.write("# Version: " + config.get('AGIXT_VERSION', 'unknown') + "\n")
            f.write("# Generated: " + config.get('INSTALL_DATE', 'unknown') + "\n")
            f.write("# Model: " + config.get('FINAL_MODEL_NAME', config.get('MODEL_NAME', 'unknown')) + "\n")
            f.write("# Architecture: " + config.get('MODEL_ARCHITECTURE_TYPE', 'unknown') + "\n")
            f.write("# =============================================================================\n\n")
            
            # Write organized sections
            for category, keys in categories.items():
                f.write("# " + "=" * 77 + "\n")
                f.write("# " + category + "\n")
                f.write("# " + "=" * 77 + "\n")
                
                # Write values for this category
                for key in keys:
                    if key in config:
                        value = config[key]
                        f.write(key + "=" + str(value) + "\n")
                
                f.write("\n")
        
        log("‚úÖ .env file created successfully", "SUCCESS")
        
        # Create docker-compose.yml - EXACTLY LIKE WORKING INSTALLER
        log("üê≥ Updating docker-compose.yml...")
        
        # CORRECTED: Match the working installer's docker-compose structure exactly
        docker_compose_content = f"""version: '3.8'

services:
  agixt:
    image: joshxt/agixt:main
    container_name: agixt
    ports:
      - "7437:7437"
    volumes:
      - {install_path}/agixt:/app/agixt
      - {install_path}/conversations:/app/conversations
      - {install_path}/.env:/app/.env
    environment:
      - AGIXT_URI=http://agixt:7437
    networks:
      - agixt-network
    restart: unless-stopped

  ezlocalai:
    image: joshxt/ezlocalai:main
    container_name: ezlocalai
    ports:
      - "8091:8091"
      - "8502:8502"
    volumes:
      - {install_path}/ezlocalai:/app/models
      - {install_path}/.env:/app/.env
    environment:
      - EZLOCALAI_URL=http://ezlocalai:8091
      - EZLOCALAI_API_KEY=${{EZLOCALAI_API_KEY}}
    networks:
      - agixt-network
    restart: unless-stopped

  agixtinteractive:
    image: joshxt/agixt-interactive:main
    container_name: agixtinteractive
    ports:
      - "3437:3437"
    volumes:
      - {install_path}/.env:/app/.env
    environment:
      - AGIXT_SERVER=${{AGIXT_URI}}
      - APP_NAME=${{APP_NAME}}
      - APP_DESCRIPTION=${{APP_DESCRIPTION}}
      - AGIXT_AGENT=${{AGIXT_AGENT}}
      - AGIXT_SHOW_SELECTION=${{AGIXT_SHOW_SELECTION}}
      - AGIXT_SHOW_AGENT_BAR=${{AGIXT_SHOW_AGENT_BAR}}
      - AGIXT_SHOW_APP_BAR=${{AGIXT_SHOW_APP_BAR}}
      - AGIXT_CONVERSATION_MODE=${{AGIXT_CONVERSATION_MODE}}
      - INTERACTIVE_MODE=${{INTERACTIVE_MODE}}
      - THEME_NAME=${{THEME_NAME}}
      - AGIXT_FOOTER_MESSAGE=${{AGIXT_FOOTER_MESSAGE}}
      - AUTH_WEB=${{AUTH_WEB}}
      - AGIXT_FILE_UPLOAD_ENABLED=${{AGIXT_FILE_UPLOAD_ENABLED}}
      - AGIXT_VOICE_INPUT_ENABLED=${{AGIXT_VOICE_INPUT_ENABLED}}
      - AGIXT_SHOW_OVERRIDE_SWITCHES=${{AGIXT_SHOW_OVERRIDE_SWITCHES}}
    networks:
      - agixt-network
    depends_on:
      - agixt
    restart: unless-stopped

networks:
  agixt-network:
    driver: bridge
"""
        
        docker_compose_path = os.path.join(install_path, "docker-compose.yml")
        with open(docker_compose_path, 'w') as f:
            f.write(docker_compose_content)
        
        log("‚úÖ docker-compose.yml updated successfully", "SUCCESS")
        
        # Create required directories that the working installer expects
        required_dirs = [
            os.path.join(install_path, "agixt"),
            os.path.join(install_path, "conversations")
        ]
        
        for dir_path in required_dirs:
            os.makedirs(dir_path, exist_ok=True)
            log("üìÅ Created directory: " + dir_path, "SUCCESS")
        
        # Verify configuration files exist
        required_files = [".env", "docker-compose.yml"]
        for file in required_files:
            file_path = os.path.join(install_path, file)
            if os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                log("‚úÖ " + file + " created (" + str(file_size) + " bytes)", "SUCCESS")
            else:
                log("‚ùå " + file + " creation failed", "ERROR")
                return False
        
        log("üîß Docker configuration completed successfully", "SUCCESS")
        return True
        
    except Exception as e:
        log("‚ùå Error creating Docker configuration: " + str(e), "ERROR")
        return False

def start_services(install_path, config):
    """Start Docker Compose services with proper error handling and monitoring"""
    
    try:
        log("üöÄ Starting AGiXT services...")
        
        # Change to installation directory
        original_cwd = os.getcwd()
        os.chdir(install_path)
        
        # Stop any existing services first
        log("üõë Stopping any existing services...")
        subprocess.run(
            ["docker", "compose", "down"],
            capture_output=True,
            text=True,
            timeout=60
        )
        
        # Start services with build if needed
        log("üîÑ Starting services with docker-compose...")
        result = subprocess.run(
            ["docker", "compose", "up", "-d", "--remove-orphans"],
            capture_output=True,
            text=True,
            timeout=300
        )
        
        if result.returncode != 0:
            log("‚ùå Failed to start services: " + result.stderr, "ERROR")
            os.chdir(original_cwd)
            return False
        
        log("‚úÖ Docker services started successfully", "SUCCESS")
        
        # Monitor service startup
        log("‚è≥ Waiting for services to initialize...")
        
        # Wait for services to be ready (reduced time since no model loading issues expected)
        log("ü§ñ Waiting for services to start (60 seconds)...")
        time.sleep(60)
        
        # Show service status
        log("üìä Checking service status...")
        result = subprocess.run(
            ["docker", "compose", "ps", "--format", "table"],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        if result.returncode == 0:
            log("üê≥ Service Status:")
            for line in result.stdout.split('\n'):
                if line.strip():
                    print("     " + line)
        
        # Final service verification
        log("üîç Final service verification...")
        result = subprocess.run(
            ["docker", "compose", "ps", "--format", "json"],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        if result.returncode == 0:
            try:
                import json
                services = []
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        service_info = json.loads(line)
                        services.append(service_info)
                
                running_services = [s for s in services if 'running' in s.get('State', '').lower()]
                log("‚úÖ " + str(len(running_services)) + "/" + str(len(services)) + " services running", "SUCCESS")
                
                for service in services:
                    name = service.get('Name', 'Unknown')
                    state = service.get('State', 'Unknown')
                    if 'running' in state.lower():
                        log("  ‚úÖ " + name + ": " + state, "SUCCESS")
                    else:
                        log("  ‚ö†Ô∏è  " + name + ": " + state, "WARN")
                        
            except Exception:
                # Fallback to simple check
                if "running" in result.stdout.lower():
                    log("‚úÖ Services appear to be running", "SUCCESS")
                else:
                    log("‚ö†Ô∏è  Some services may not be running properly", "WARN")
        
        os.chdir(original_cwd)
        log("üéâ Service startup completed", "SUCCESS")
        return True
        
    except Exception as e:
        log("‚ùå Error starting services: " + str(e), "ERROR")
        try:
            os.chdir(original_cwd)
        except:
            pass
        return False

# Module test function
def test_module():
    """Test this module's functionality"""
    log("üß™ Testing installer_docker module...")
    
    # Test configuration creation with mock config
    test_config = {
        'AGIXT_VERSION': 'v1.6-test',
        'INSTALL_DATE': '2025-06-02T00:00:00',
        'AGIXT_API_KEY': 'test_api_key_12345678',
        'MODEL_NAME': 'test-model',
        'FINAL_MODEL_NAME': 'test-model-final',
        'MODEL_ARCHITECTURE_TYPE': 'llama',
        'THREADS': '4',
        'GPU_LAYERS': '0',
        'DEFAULT_MODEL': 'test-model-final',
        'LLM_MAX_TOKENS': '4096',
        'APP_NAME': 'Test AGiXT',
        'AGIXT_URI': 'http://agixt:7437',
        'HUGGINGFACE_TOKEN': 'test_token'
    }
    
    # Test that functions exist and are callable
    if callable(create_configuration):
        log("create_configuration function: ‚úì", "SUCCESS")
    else:
        log("create_configuration function: ‚úó", "ERROR")
    
    if callable(start_services):
        log("start_services function: ‚úì", "SUCCESS")
    else:
        log("start_services function: ‚úó", "ERROR")
    
    log("‚úÖ installer_docker module test completed", "SUCCESS")
    return True

if __name__ == "__main__":
    # Run module test if executed directly
    test_module()
